#!/usr/bin/env python

""" 
Python interface to Q-Chem, very useful for automating Q-Chem calculations.

Contains a QChem class representing a Q-Chem calculation, where calling
methods like sp() and make_stable() produces Q-Chem results wrapped up in
a Molecule object.

Also contains a number of functions to wrap around TS/IRC calculations and
make the results easier to use.
"""
from __future__ import print_function
import os, sys, shutil, glob
import traceback
import time
import numpy as np
from .molecule import Molecule, Elements, arc
from .nifty import _exec, monotonic_decreasing
from collections import defaultdict, OrderedDict
from copy import deepcopy

# Note: On biox3 there are MPI problems.

# Default Q-Chem input file to be used when QChem class is initialized
# from a .xyz file.  Written mainly for HF and DFT calculations; note
# the relatively conservative settings.
qcrem_default = """
$molecule
{chg} {mult}
$end

$rem
method              {method}{pcm}
basis               {basis}
unrestricted        true
symmetry            off
sym_ignore          true
incdft              false
incfock             0
scf_convergence     8
thresh              14
$end
"""

vib_top = """#==========================================#
#| File containing vibrational modes from |#
#|           Q-Chem calculation           |#
#|                                        |#
#| Octothorpes are comments               |#
#| This file should be formatted like so: |#
#| (Full XYZ file for the molecule)       |#
#| Number of atoms                        |#
#| Comment line                           |#
#| a1 x1 y1 z1 (xyz for atom 1)           |#
#| a2 x2 y2 z2 (xyz for atom 2)           |#
#|                                        |#
#| These coords will be actually used     |#
#|                                        |#
#| (Followed by vibrational modes)        |#
#| Do not use mass-weighted coordinates   |#
#| ...                                    |#
#| v (Eigenvalue in wavenumbers)          |#
#| dx1 dy1 dz1 (Eigenvector for atom 1)   |#
#| dx2 dy2 dz2 (Eigenvector for atom 2)   |#
#| ...                                    |#
#| (Empty line is optional)               |#
#| v (Eigenvalue)                         |#
#| dx1 dy1 dz1 (Eigenvector for atom 1)   |#
#| dx2 dy2 dz2 (Eigenvector for atom 2)   |#
#| ...                                    |#
#| and so on                              |#
#|                                        |#
#| Please list freqs in increasing order  |#
#==========================================#
"""

# Handle known errors.
# Reaction path errors culled from Q-Chem source.
# Spelling errors are probably not mine.
erroks = defaultdict(list)
erroks['rpath'] = ['Bad Hessian -- imaginary mode too soft', 'Bad Hessian -- no negative eigenvalue',
                   'Bad initial gradient', 'Failed line search', 'First_IRC_step: Illegal value of coordinates',
                   'First_IRC_step: Internal programming error.', 'IRC backup failure', 'IRC failed bisector line search',
                   'IRC failed final bisector step', 'IRC --- Failed line search', 'IRC internal programming error',
                   'Maxium number of steps reached.', 'NAtom.GT.NAtoms', 'RPATH_ITER_MAX reached.',
                   'rpath_new: EWCs not yet implemented', 'rpath_new: Unimplemented coordinates',
                   'RPath_new: unimplemented coordinates.', 'rpath: no hessian at the start.',
                   'rpath: Starting Geometry Does NOT Correspond to TS']
erroks['opt'] = ['OPTIMIZE fatal error']

def tarexit(exitstat=0):
    """
    Archive files and quit.  It's helpful for remote scripts to call this.
    Note that tarexit.tarfnm and tarexit.include need to be set.

    Fields (basically globals)
    ------
    tarfnm : str
        Name of the archive to create.
    include : list or str
        Files to be archived; each entry is expanded using glob.
    exclude : list or str
        Exclude files from being archived; these are expanded using glob.
    save : list or str
        Do not remove these files even when remove_files is set to True
    archive_dirs : bool
        If set to True, directories will be archived as well.
    remove_files : bool
        If set to True, everything that is archived will be removed using --remove-files.
    remove_dirs : bool
        If set to True, all subdirectories ending in '.d' (generated by Q-Chem) will be removed.

    Parameters
    ----------
    exitstat : int
        Use this exit status.  Note that exit status > 0 indicates error.
    """
    # Type checking, make everything into a list
    if isinstance(tarexit.include, str):
        tarexit.include = [tarexit.include]
    if isinstance(tarexit.exclude, str):
        tarexit.exclude = [tarexit.exclude]
    # Remove .btr files created by OpenMPI (I think?) as well as existing .tar file.
    for f in glob.glob('*.btr'):
        os.remove(f)
    # Expand each term in "exclude" and remove from the list of files.
    excludes = sum([glob.glob(g) for g in tarexit.exclude], [])
    # If the tar file exists, then extract / delete it.
    if os.path.exists(tarexit.tarfnm):
        _exec("tar xjf %s --skip-old-files" % tarexit.tarfnm, print_command=True)
        os.remove(tarexit.tarfnm)
    # Expand each term in "include" and add them to the list of files.
    include_files = []
    for g in tarexit.include:
        for f in glob.glob(g):
            # Conditions for including paths in archive list:
            # 1) Path isn't added already
            # 2) Path isn't in the list of exclusions
            # 3) Either archive_dirs is set or path is not a folder
            if f not in include_files and f not in excludes and (tarexit.archive_dirs or (not os.path.isdir(f))):
                include_files.append(f)
    # Files ending in .log are never deleted
    if tarexit.remove_files:
        saved = [f for f in sum([glob.glob(g) for g in tarexit.save], []) if f in include_files]
        if not os.path.exists('saved'):
            os.makedirs('saved')
        for f in saved:
            shutil.copy2(f, 'saved/%s' % f)
    # Actually execute the tar command.
    _exec("tar cjf %s %s%s" % (tarexit.tarfnm, ' '.join(include_files), ' --remove-files' if tarexit.remove_files else ''), print_command=True)
    # Touch the file to ensure that something is created (even zero bytes).
    _exec("touch %s" % tarexit.tarfnm)
    if tarexit.remove_files:
        for f in saved:
            shutil.copy2('saved/%s' % f, f)
        shutil.rmtree('saved')
    # Delete directories that end in .d if desired.
    for f in os.listdir('.'):
        if tarexit.remove_dirs and os.path.isdir(f) and ('.d' in f):
            shutil.rmtree(f)
    sys.exit(exitstat)
tarexit.tarfnm = 'default.tar.bz2'
tarexit.include = []
tarexit.exclude = []
tarexit.save = ['*.log']
tarexit.archive_dirs=False
tarexit.remove_files=True
tarexit.remove_dirs=True

# Basis set combinations which may be provided as an argument to "basis".
# Provides rudimentary basis set mixing functionality.  You may define
# a mapping from element to basis set here.
basdict = OrderedDict([('%s_lanl2dz' % bas, OrderedDict([(Elements[i], 'lanl2dz' if i > 10 else bas) for i in range(1, 94)])) for
                       bas in ['3-21g', '3-21+g', '3-21g*', 
                               '6-31g', '6-31g*', '6-31g(d)', '6-31g**', '6-31g(d,p)',
                               '6-31+g', '6-31+g*', '6-31+g(d)', '6-31+g**', '6-31+g(d,p)',
                               '6-31++g', '6-31++g*', '6-31++g(d)', '6-31++g**', '6-31++g(d,p)',
                               '6-311g', '6-311g*', '6-311g(d)', '6-311g**', '6-311g(d,p)',
                               '6-311+g', '6-311+g*', '6-311+g(d)', '6-311+g**', '6-311+g(d,p)',
                               '6-311++g', '6-311++g*', '6-311++g(d)', '6-311++g**', '6-311++g(d,p)']])

# In most cases, the ECP can be determined from the basis
ecpdict = OrderedDict([('lanl2dz', 'lanl2dz')] + 
                      [('%s_lanl2dz' % bas, 'lanl2dz') for
                       bas in ['3-21g', '3-21+g', '3-21g*', 
                               '6-31g', '6-31g*', '6-31g(d)', '6-31g**', '6-31g(d,p)',
                               '6-31+g', '6-31+g*', '6-31+g(d)', '6-31+g**', '6-31+g(d,p)',
                               '6-31++g', '6-31++g*', '6-31++g(d)', '6-31++g**', '6-31++g(d,p)',
                               '6-311g', '6-311g*', '6-311g(d)', '6-311g**', '6-311g(d,p)',
                               '6-311+g', '6-311+g*', '6-311+g(d)', '6-311+g**', '6-311+g(d,p)',
                               '6-311++g', '6-311++g*', '6-311++g(d)', '6-311++g**', '6-311++g(d,p)']])

def get_basis(basis, molecule=None):
    """
    Get the basis / ECP name and section data for a Q-Chem input file.

    Parameters
    ----------
    basis : str
        Name of a Q-Chem gaussian basis set or a custom basis as defined above
    molecule : Molecule object
        Required in case of a general basis (for looking up elements in the basis set dictionary)
    
    Returns
    -------
    basisname : str
        Either the original basis name or "gen" for a general basis
    basissect : None or list
        A list of strings for the $basis section in case of a general basis
    ecpname : None or str
        None (for no ECP), the original ECP name, or "gen" for a general ECP
    ecpname : None or list
        A list of strings for the $ecp section in case of a general ECP
    """
    # Look up the basis set (string or dictionary).
    basisval = basdict.get(basis.lower(), basis)
    if molecule != None:
        elems = sorted(list(set(molecule.elem)))
        elemsort = np.argsort(np.array([Elements.index(i) for i in elems]))
        elems = [elems[i] for i in elemsort]
    elif isinstance(basisval, dict):
        raise RuntimeError('Please pass a molecule object if using a general basis set')
    basissect = None
    if isinstance(basisval, dict):
        basisname = 'gen'
        basissect = sum([[e, basisval[e], '****'] for e in elems], [])
    else:
        basisname = basisval.lower()
    # Look up the ECP (string, dictionary or None).
    ecp = ecpdict.get(basis.lower(), None)
    ecpname = None
    ecpsect = None
    if isinstance(ecp, dict):
        ecpname = 'gen'
        ecpsect = sum([[e, ecp[e], '****'] for e in elems], [])
    elif isinstance(ecp, str):
        ecpname = ecp.lower()
    return basisname, basissect, ecpname, ecpsect

def prepare_template(docstring, fout, chg, mult, method, basis, epsilon=None, molecule=None):
    """
    Prepare a Q-Chem template file.

    Parameters
    ----------
    docstring : str
        A Python docstring with the fields {chg}, {mult}, {method} and {basis} defined.
    fout : str
        Name of the output file.
    chg : int
        Charge to print to the template file.
    mult : int
        Spin multiplicity.
    method : str
        Electronic structure method.
    basis : str
        Gaussian basis set.
    molecule : Molecule object
        molecule.elem provides the elements printed to file in the case of a general basis
    """
    basisname, basissect, ecpname, ecpsect = get_basis(basis, molecule)
    # Write Q-Chem template file.
    with open(fout,'w') as f: print(docstring.format(chg=chg, mult=mult, method=method, pcm=('\nsolvent_method      cosmo' if epsilon is not None else ''), basis=(basisname + '%s' % (('\necp                 %s' % ecpname) if ecpname != None else ''))), file=f)
    # Print general basis and ECP sections to the Q-Chem template file.
    if epsilon is not None:
        with open(fout,'a') as f:
            print(file=f)
            print('$solvent', file=f)
            print('dielectric %f' % epsilon, file=f)
            print('$end', file=f)
    if basisname == 'gen':
        with open(fout,'a') as f:
            print(file=f)
            print('$basis', file=f)
            print('\n'.join(basissect), file=f)
            print('$end', file=f)
    if ecpname == 'gen':
        with open(fout,'a') as f:
            print(file=f)
            print('$ecp', file=f)
            print('\n'.join(ecpsect), file=f)
            print('$end', file=f)

class QChem(object):
    """
    Class for facilitating Q-Chem calculations.  I wrote this
    because it was helpful to execute a chain of calculations on a
    single geometry.
    """
    def __init__(self, fin, ftype=None, charge=None, mult=None, method=None,
                 basis=None, qcin=None, qcout=None, qcdir=None, readsave=None,
                 readguess=True, clean=False, qcsave=True):
        """
        Create a QChem object.

        Parameters
        ----------
        fin : str
            Name of input .xyz or .in file (other coordinate files in
            molecule.py supported as well).  The .in file will contain
            settings for the Q-Chem calculation whereas the .xyz file
            does not; in this case, default fields are filled in, but
            the user must procide charge / mult / method / basis.
        ftype : str, optional
            Force the Molecule class to read the input file as this format.
        charge : int, optional
            Net charge.  Required if xyz coordinates are provided.  If
            Q-Chem input and charge are both provided, this will override.
        mult : int, optional
            Spin multiplicity.  Required if xyz coordinates are provided.
            If Q-Chem input and mult are both provided, this will override.
        method : str, optional
            Electronic structure method (e.g. b3lyp).  This is written
            to the "method" field in the Q-Chem input file - supported
            by Q-Chem 4.2 and later.  Required if xyz coordinate are
            provided.  If Q-Chem input and method are both provided, this
            will override.
        basis : str, optional
            Gaussian basis set (e.g. 6-31g*).  This is written to the
            "basis" field in the Q-Chem input file.  Required if xyz
            coordinate are provided.  If Q-Chem input and basis
            are both provided, this will override.
        qcin : str, optional
            Base name of Q-Chem input files to be written.  If not provided,
            will use "fin" (extension will be changed to ".qcin" if necessary
            to avoid overwriting input file.)
        qcout : str, optional
            Base name of Q-Chem output files.  If not provided, will use "qcin"
            base name and ".out" extension.
        qcdir : str, optional
            Base name of Q-Chem temporary folder.  If not provided, will use "qcin"
            base name and ".d" extension.  NOTE: This folder will be removed prior
            to calculation start!  Also, will create a ".dsav" folder used to recover
            from failed calculations, think of it as a "save game file".
        readsave : str or bool, optional
            If set to True, the "qcdsav" (i.e. qcdir+"sav") folder will automatically
            be used to initialize this calculation.
            If string, this is a folder containing Q-Chem files used to initialize
            this calculation.  This folder will be copied to "self.qcdsav" and self.qcdsav
            will NOT be removed prior to calculation start.
            If not provided, self.qcdsav will be removed prior to calculation start.
        readguess : bool, optional
            Write "scf_guess read" to Q-Chem input file.  If readsave is provided,
            then the very first calculation will read the SCF guess as well.
        clean : bool, optional
            When set, this calculation never updates qcdsav.  However, if readsave is
            provided it will still be used to initialize each calculation.  Use this
            if you never want the calculation result to depend on the previous state.
            Note that this is relatively uncommon (e.g. if we want to run a series
            of calculations without reading the SCF guess from the previous one.)
        qcsave : bool, optional
            Append the "-save" argument to the system call to Q-Chem.  This results
            in more files being saved to qcdir.
        """
        # Name of the input file.
        self.fin = fin
        # Molecule object from loading the input file.
        self.M = Molecule(fin, ftype)
        if 'elem' not in list(self.M.Data.keys()):
            raise RuntimeError('Input file contains no atoms')
        # Q-Chem input file that will be written for each Q-Chem execution.
        # If the original input file happens to also be a Q-Chem input file,
        # then use the suffix 'qcin' add an underscore so we
        # don't accidentally overwrite our original file.
        if qcin == None:
            qcin = os.path.splitext(fin)[0]+'.in'
        if qcin == fin and fin.endswith('.in'):
            self.qcin = os.path.splitext(fin)[0]+'.qcin'
        elif qcin == fin:
            raise RuntimeError('Please do not provide a file with extension .qcin')
        else:
            self.qcin = qcin
        # Keep track of the number of calculations done.
        self.ncalc = 0
        # Whether a Hessian calculation has been done.
        self.haveH = 0
        # Set Q-Chem calculation options ($rem variables).
        if 'qcrems' not in list(self.M.Data.keys()):
            if method == None or basis == None or charge == None or mult == None:
                raise RuntimeError('Must provide charge/mult/method/basis!')
            # Print a Q-Chem template file.
            prepare_template(qcrem_default, '.qtemp.in', charge, mult, method, basis, molecule=self.M)
            self.M.add_quantum('.qtemp.in')
        else:
            if charge != None:
                self.M.charge = charge
            if mult != None:
                self.M.mult = mult
            if method != None:
                self.M.edit_qcrems({'method' : method})
            # Treat custom basis and ECP.
            ecpname = None
            ecpsect = None
            if basis != None:
                basisname, basissect, ecpname, ecpsect = get_basis(basis, self.M)
                self.M.edit_qcrems({'basis' : basisname})
                if basisname == 'gen':
                    self.M.qctemplate['basis'] = basissect
            if ecpname != None:
                self.M.edit_qcrems({'ecp' : ecpname})
                if ecpname == 'gen':
                    self.M.qctemplate['ecp'] = ecpsect
        # The current job type, which we can set using
        # different methods for job types.
        self.jobtype = 'sp'
        # Rem dictionary for SCF convergence.
        self.remscf = OrderedDict()
        # Extra rem variables for a given job type.
        self.remextra = OrderedDict()
        # Default name of Q-Chem output file
        self.qcout = os.path.splitext(self.qcin)[0]+".out" if qcout == None else qcout
        self.qcerr = os.path.splitext(self.qcin)[0]+".err"
        # Saved Q-Chem calculations if there is more than one.
        self.qcins = []
        self.qcouts = []
        self.qcerrs = []
        # Specify whether to tack "-save" onto the end of each Q-Chem call.
        self.qcsave = qcsave
        # Q-Chem scratch directory
        self.qcdir = os.path.splitext(self.qcin)[0]+".d" if qcdir == None else qcdir
        # Flag to read SCF guess at the first calculation
        self.readguess = readguess
        # Without guess to read from, use "scf_guess core"
        # and "scf_guess_mix 5" which allows us to find broken
        # symmetry states.
        self.coreguess = True
        # Error message if the calculation failed for a known reason
        self.errmsg = ''
        # qcdsav is "known-good qcdir for this object",
        # used to restore from failed calcs (e.g. SCF failure)
        self.qcdsav = self.qcdir+'sav'
        #--------
        # The clean option makes sure nothing on the disk influences this calculation.
        # This can be a bit confusing.  There are two modes of usage:
        # 1) Clean OFF.  Calculation uses whatever is in qcdir and backs it up to qcdsav on successful calcs.
        # 2) Clean ON.  qcdir is always cleared, and copied over from qcdsav (if exist) prior to calling Q-Chem.
        # This allows us to save the state of a good calculation without worrying about outside interference.
        # - Use case 1: AnalyzeReaction.py does not like to read SCF guesses from previous calculations so we use clean = True.
        # - Use case 2: Growing string does like to read SCF guesses so we use clean = False.
        # - Use case 3: IRC calculation requires Hessian from a previous calculation, so again we use clean = False.
        self.clean = clean
        # If readsave is set, then copy it to self.qcdsav and it will be used
        # to initialize this calculation.  Otherwise self.qcdsav will be removed.
        self.readsave = readsave
        if isinstance(self.readsave, str):
            if not os.path.isdir(self.readsave):
                raise RuntimeError('Tried to initialize Q-Chem reading from a save folder but does not exist')
            if self.readsave == self.qcdsav: pass
            elif os.path.exists(self.qcdsav):
                shutil.rmtree(self.qcdsav)
                shutil.copytree(self.readsave, self.qcdsav)
        elif isinstance(self.readsave, int) and self.readsave: pass
        elif os.path.exists(self.qcdsav): shutil.rmtree(self.qcdsav)
        # Remove self.qcdir; it will be restored from self.qcdsav right before calling Q-Chem.
        if os.path.exists(self.qcdir): shutil.rmtree(self.qcdir)

    def write(self, *args, **kwargs):
        """ Write the Molecule object to a file. """
        self.M.write(*args, **kwargs)

    def write_qcin(self):
        """ Write Q-Chem input file. """
        rems = OrderedDict([('jobtype', self.jobtype)])
        rems['scf_convergence'] = 8
        # If not the first calculation, read SCF guess from the first calculation.
        if self.readguess and os.path.exists(self.qcdsav):
            rems['scf_guess'] = 'read'
            rems['scf_guess_mix'] = None
        elif self.coreguess:
            rems['scf_guess'] = 'core'
            rems['scf_guess_mix'] = 5
        # Add SCF convergence rem variables.
        rems.update(self.remscf)
        # Add job-related rem variables.
        rems.update(self.remextra)
        # If doing stability analysis, loosen SCF convergence tolerance by 1.
        # This is a bootleg solution to our workflow hanging indefinitely
        # when Q-Chem crashes.
        if 'stability_analysis' in list(rems.keys()):
            rems['scf_convergence'] -= 2
        # Create copy of stored Molecule object, update
        # Q-Chem rem variables and write Q-Chem input file.
        M1 = deepcopy(self.M)
        M1.edit_qcrems(rems)
        M1.write(self.qcin, ftype="qcin")

    def DIE(self, errmsg):
        """ Does what it says. """
        raise RuntimeError("Error: Q-Chem calculation failed! (%s)" % errmsg)

    def load_qcout(self):
        """
        Return Molecule object corresponding to Q-Chem output
        file. SCF convergence failures and maximum optimization cycles
        reached will not trigger a parser error.
        """
        try:
            return Molecule(self.qcout, errok=erroks[self.jobtype.lower()] + ['SCF failed to converge', 'Maximum optimization cycles reached'])
        except RuntimeError:
            tarexit.include=['*']
            tarexit(1)

    def call_qchem(self, debug=False):
        """
        Call Q-Chem.  There are several functions that wrap
        around this innermost call.  Assumes that Q-Chem input
        file has been written.

        Determine whether to run in serial, OpenMP-parallel or
        MPI-parallel mode. Restore qcdir from qcdsav. Execute
        Q-Chem executable but don't copy qcdir back to qcdsav
        (outer wrapper functions should do this).
        """
        if debug:
            print("Calling Q-Chem with jobtype", self.jobtype)
            for line in open(self.qcin).readlines():
                print(line, end=' ')

        # Figure out whether to use OpenMP or MPI.
        mode = "openmp"
        M1 = Molecule(self.qcin)
        for qcrem in M1.qcrems:
            for key in list(qcrem.keys()):
                if key == 'stability_analysis' and qcrem[key].lower() == 'true':
                    mode = "mpi"
                if key == 'jobtype' and qcrem[key].lower() == 'freq':
                    mode = "mpi"
        # Currently Lisa is experiencing errors like:
        # These need to be troubleshot
        # p0_2335:  p4_error: : 17
        # rm_l_1_3716: rm_l_3_3764: (9.847656) net_send: could not write to fd=5, errno = 32
        if mode == "mpi": mode = "serial"

        # Set commands to run Q-Chem.
        # The OMP_NUM_THREADS environment variable shall be used to determine
        # the number of processors.  The environment variable is then unset.
        # If not set, default to one.
        if 'OMP_NUM_THREADS' in os.environ:
            cores=int(os.environ['OMP_NUM_THREADS'])
            del os.environ['OMP_NUM_THREADS']
        else:
            cores=1
        # Q-Chem parallel (OpenMP), serial, and parallel (MPI) commands.
        # The MPI command is useful for jobs that aren't OpenMP-parallel,
        # such as stability analysis (which uses TDDFT/CIS).
        if 'QCCMD' in os.environ:
            qccmd = os.environ['QCCMD']
        else:
            qccmd = "qchem -nt %i" % cores
        # Command for serial jobs
        qc1cmd = qccmd.split()[0]
        # Command for MPI jobs
        # qcmpi = "qchem"
        qcmpi = qccmd.replace('-nt', '-np')
        # I believe this saves more scratch files from Q-Chem.
        if self.qcsave:
            qccmd += ' -save'
            qc1cmd += ' -save'
            qcmpi += ' -save'

        # Frequency calculations with less atoms than the # of cores should be serial.
        if M1.na < cores and self.jobtype.lower() == 'freq': mode = "serial"

        # I don't remember why this is here.  Something about "Recomputing EXC"?
        # if 'scf_algorithm' in self.remscf and self.remscf['scf_algorithm'] == 'rca_diis': mode = "serial"

        #----
        # Note that on some clusters I was running into random
        # crashes, which led to this code becoming more complicated.
        # The code is now cleaned up because I haven't seen the errors
        # in a while .. but if they come back, make sure to look back
        # in the commit history.
        #----

        # When "clean mode" is on, we always start from a clean slate
        # (restore qcdir from qcdsav if exist; otherwise delete)
        if (self.clean or os.path.exists(self.qcdsav)) and os.path.exists(self.qcdir):
            shutil.rmtree(self.qcdir)
        # If qcdsav exists, we restore from it
        if os.path.exists(self.qcdsav):
            _exec("rsync -a --delete %s/ %s/" % (self.qcdsav, self.qcdir), print_command=False)
        # Execute Q-Chem.
        if mode == "openmp":
            qccmd_ = qccmd
        elif mode == "mpi":
            qccmd_ = qcmpi
            for i in range(cores):
                _exec("hostname >> machines", print_command=False)
            os.environ["QCMACHINEFILE"] = "machines"
            # with open("machines","w") as f:
            #     print >> f, os.environ["HOSTNAME"]
            # Force BW compute node to use single processor instead of MPI.
            # LPW 2016-04-18: This code may no longer be needed
            # if 'nid' in os.environ.get('HOSTNAME', 'None'):
            #     qccmd_ = qc1cmd
        elif mode == "serial":
            qccmd_ = qc1cmd
        try:
            _exec('%s %s %s %s &> %s' % (qccmd_, self.qcin, self.qcout, self.qcdir, self.qcerr), print_command=False)
        except:
            tarexit.include=['*']
            tarexit(1)
        # MPI mode creates several copies of qcdir which are not needed.
        if mode == "mpi":
            _exec("rm -rf %s.*" % self.qcdir)
        # Catch known Q-Chem crashes. :(
        # I've run into a lot of TCP socket errors and OpenMP segfaults on Blue Waters.
        for line in open(self.qcerr):
            if 'Unable to open a TCP socket for out-of-band communications' in line:
                with open(self.qcerr, 'a') as f: print('TCP socket failure :(', file=f)
                tarexit.include=['*']
                tarexit(1)
        # Note that we do NOT copy qcdir to qcdsav here, because we don't know whether the calculation is good.
        # Delete the strange .btr files that show up on some clusters.
        _exec('rm -rf *.btr', print_command=False)
        # Reset the OMP_NUM_THREADS environment variable.
        os.environ['OMP_NUM_THREADS'] = str(cores)

    def scf_tactic(self, attempt=1):
        """
        Set the SCF convergence strategy.

        First attempt uses 100 SCF iterations,
        all subsequent attempts use 300 SCF iterations.

        Attempt 1: DIIS with core / read guess.
        Attempt 2: RCA with SAD guess.
        Attempt 3: GDM with core / read guess.
        Attempts 4-6: Sleazy SCF convergence with the above strategies.

        Note that readguess and coreguess are not explicitly set in
        self.remscf because their activation depends on the existence
        of self.qcdsav.
        """
        self.remscf = OrderedDict()
        # Set SCF convergence algorithm.
        if attempt in [1, 4]:
            self.readguess = True
            self.coreguess = True
            self.remscf['scf_algorithm'] = 'diis'
        if attempt in [2, 5]:
            print("RCA..", end=' ')
            self.readguess = False
            self.coreguess = False
            self.remscf['scf_algorithm'] = 'rca_diis'
            self.remscf['thresh_rca_switch'] = 4
        if attempt in [3, 6]:
            print("GDM..", end=' ')
            self.readguess = True
            self.coreguess = True
            self.remscf['scf_algorithm'] = 'diis_gdm'
        # Set SCF convergence criterion.
        if attempt <= 3:
            self.remscf['scf_convergence'] = 8
        else:
            if attempt == 4:
                print("Relax convergence criterion..", end=' ')
            self.remscf['scf_convergence'] = 6
        # Set SCF max number of cycles.
        if attempt > 1:
            self.remscf['max_scf_cycles'] = 300
        else:
            self.remscf['max_scf_cycles'] = 100

    def converge(self, attempt=1):
        """ Attempt to converge the SCF. """
        while True:
            self.scf_tactic(attempt)
            self.write_qcin()
            # Note to self: Within this approach, each SCF algorithm
            # starts from either (1) the initial guess or (2) the MOs
            # from qcdsav.  That is to say, the subsequent attempts
            # do NOT read partially converged solutions from the previous
            # attempts.
            self.call_qchem()
            if all(["failed to converge" not in line and \
                        "Convergence failure" not in line \
                        for line in open(self.qcout)]): break
            attempt += 1
            if attempt > 6:
                self.DIE("SCF convergence failure")
        # Reset the SCF tactic back to 1 after convergence.
        # Note: This is a bit controversial. :)
        self.scf_tactic(1)
        # If not running in "clean mode", the qcdsav folder is updated.
        if not self.clean:
            _exec("rsync -a --delete %s/ %s/" % (self.qcdir, self.qcdsav), print_command=False)
        return attempt

    def converge_opt(self):
        """
        SCF convergence forcing for geometry optimization jobs.
        This function exists because SCF convergence may fail for a geometry optimization.
        When this happens, we run SP calculations with different SCF algorithms, and then
        we may either do the geometry optimization with this new SCF algorithm or revert
        back to the first one.
        """
        optouts = []
        thisopt = 1
        # SCF tactic for the optimization itself.
        # If any point in the optimization requires an alternate
        # algorithm, we continue the optimization using that.
        attempt = 1
        while True:
            self.scf_tactic(attempt)
            self.write_qcin()
            self.call_qchem()
            M1 = self.load_qcout()
            # For any optimization with at least one step,
            # we copy it to a temporary file to be joined at the end.
            if len(M1.qm_energies) >= (2 if (M1.qcerr == 'SCF failed to converge') else 1):
                optouts.append('.opt%i.out' % thisopt)
                _exec('cp %s .opt%i.out' % (self.qcout, thisopt), print_command=False)
                thisopt += 1
            if M1.qcerr in ['SCF failed to converge', 'killed']:
                # If SCF fails to converge, try different algorithms to enforce convergence.
                self.M.xyzs = [M1.xyzs[-1]]
                jobtype0 = self.jobtype
                self.jobtype = 'sp'
                attempt = self.converge(attempt)
                # If we were running an IRC calculation, we must revert
                # to geometry optimization because not at the TS anymore.
                if jobtype0 == 'rpath':
                    self.jobtype = 'opt'
                else:
                    self.jobtype = jobtype0
            else:
                # Optimization is finished; concatenate output files.
                _exec('cat %s > %s' % (' '.join(optouts), self.qcout), print_command=False)
                break

    def calculate(self, converge=True):
        """
        Perform Q-Chem calculation.

        This is a higher-level function that wraps around converge()
        and converge_opt(), which themselves wrap around call_qchem().
        """
        if converge:
            if self.jobtype in ['opt', 'ts', 'rpath']:
                self.converge_opt()
            else:
                self.converge()
        else:
            self.call_qchem()
        # Update qcdsav (if not using clean option).
        if not self.clean:
            _exec("rsync -a --delete %s/ %s/" % (self.qcdir, self.qcdsav), print_command=False)
        # Save the sequence of Q-Chem input and output files.
        jobsuf = self.jobsuf if hasattr(self, 'jobsuf') else self.jobtype
        this_qcin = os.path.splitext(self.qcin)[0] + '.%02i.%s.in' % (self.ncalc, jobsuf)
        this_qcout = os.path.splitext(self.qcout)[0] + '.%02i.%s.out' % (self.ncalc, jobsuf)
        this_qcerr = os.path.splitext(self.qcout)[0] + '.%02i.%s.err' % (self.ncalc, jobsuf)
        _exec("cp %s %s" % (self.qcin, this_qcin), print_command=False)
        _exec("cp %s %s" % (self.qcout, this_qcout), print_command=False)
        _exec("cp %s %s" % (self.qcerr, this_qcerr), print_command=False)
        self.qcins.append(this_qcin)
        self.qcouts.append(this_qcout)
        self.qcerrs.append(this_qcerr)
        self.ncalc += 1

    def sp(self):
        """ Q-Chem single point calculation. """
        self.jobtype = 'sp'
        # Clear dictionary of extra rem variables.
        self.remextra = OrderedDict()
        self.calculate()

    def stab(self):
        """ Q-Chem stability analysis calculation. """
        self.jobtype = 'sp'
        self.jobsuf = 'stb'
        self.remextra = OrderedDict([('stability_analysis', 'true'), ('max_cis_cycles', '100'), ('cis_n_roots', '4')])
        self.calculate()
        delattr(self, 'jobsuf')

    def make_stable(self, maxstab=3):
        """ Repeat stability analysis calculation until stable. """
        self.nstab = 1
        self.stable = False
        while not self.stable:
            self.readguess = True
            self.sp()
            self.readguess = True
            self.stab()
            # Parse Q-Chem output file for stability.
            stab2 = 0
            for line in open(self.qcout):
                if "UHF-> UHF   stable" in line:
                    stab2 = 1
                if "UKS-> UKS   stable" in line:
                    stab2 = 1
            if stab2:
                self.stable = True
                if self.nstab > 1:
                    print("HF/KS stable %s" % (("at attempt %i" % self.nstab) if self.nstab > 1 else ""))
                break
            else:
                self.nstab += 1
            if self.nstab > maxstab:
                print("Warning: Stability analysis could not find HF/KS stable state")
                break

    def force(self):
        """ Q-Chem gradient calculation. """
        self.jobtype = 'force'
        self.remextra = OrderedDict()
        self.calculate()

    def freq(self):
        """ Q-Chem frequency and Hessian calculation. """
        self.jobtype = 'freq'
        self.remextra = OrderedDict()
        self.calculate()
        self.haveH = 1

    def write_vdata(self, fout):
        """ Write vibrational data to an easy-to-use text file. """
        M = self.load_qcout()
        with open(fout, 'w') as f:
            print(vib_top, file=f)
            print(M.na, file=f)
            print("Coordinates and vibrations calculated from %s" % self.qcout, file=f)
            for e, i in zip(M.elem, M.xyzs[0]):
                print("%2s % 8.3f % 8.3f % 8.3f" % (e, i[0], i[1], i[2]), file=f)
            for frq, mode in zip(M.freqs, M.modes):
                print(file=f)
                print("%.4f" % frq, file=f)
                for i in mode:
                    print("% 8.3f % 8.3f % 8.3f" % (i[0], i[1], i[2]), file=f)

    def opt(self):
        """
        Q-Chem geometry optimization.

        Updates the geometry in the object, so subsequent
        calculations use the optimized geometry.
        """
        self.jobtype = 'opt'
        self.remextra = OrderedDict([('geom_opt_max_cycles', '300')])
        self.calculate()
        M1 = self.load_qcout()
        self.M.comms = [M1.comms[-1]]
        self.M.xyzs = [M1.xyzs[-1]]

    def ts(self):
        """
        Q-Chem transition state calculation.

        Updates the geometry in the object, so subsequent
        calculations use the optimized TS geometry.
        """
        self.jobtype = 'ts'
        self.remextra = OrderedDict([('geom_opt_max_cycles', '500'),
                                     ('geom_opt_dmax', '100'),
                                     ('geom_opt_tol_gradient', '10')])
        if self.haveH:
            self.remextra['geom_opt_hessian'] = 'read'
        self.calculate()
        M1 = self.load_qcout()
        self.M.comms = [M1.comms[-1]]
        self.M.xyzs = [M1.xyzs[-1]]

    def fsm(self, nnode=21):
        """
        Q-Chem freezing string calculation.

        Updates the geometry in the object, so subsequent
        calculations use the transition state guess geometry.
        """
        self.jobtype = 'fsm'
        self.remextra = OrderedDict([('fsm_nnode', nnode),
                                     ('fsm_ngrad', 6),
                                     ('fsm_mode', 2),
                                     ('fsm_opt_mode', 2)])
        self.calculate()
        M1 = self.load_qcout()
        self.M.comms = [M1.comms[-1]]
        self.M.xyzs = [M1.xyzs[-1]]

    def rpath(self, direction=1, tolerance=1000):
        """ 
        Q-Chem intrinsic reaction coordinate calculation. 

        This calculation is by far the most difficult one to parse,
        and the return value is a dictionary that contains the IRC
        data and status messages.  The ProcessIRC function takes this
        dictionary and constructs an easy-to-use Molecule object from
        it.  It helps to use the QChemIRC() wrapper function to
        initialize this calculation from a converged transition state
        calculation.
        
        Parameters
        ----------
        direction : int, optional
            Choose the IRC direction (+1 or -1).  This only works with
            LP's edited version of Q-Chem, because currently Q-Chem
            starts IRC in the same direction regardless of this rem
            variable.
        tolerance : int, optional
            Set the IRC displacement tolerance.  Higher values will lead to
            faster convergence but occasionally give a result that converges
            in 1-2 steps (i.e. "converged" but still at the transition state).
        
        Returns
        -------
        IRCOut : OrderedDict
            IRC calculation results and status.  Entries in the dictionary are:
            X = Time series of coordinates, starting at TS and going down to 
            first minimum, then back to TS and going down to second minimum
            E = Energies, in the same order as X
            Q = Mulliken charges, in the same order as X
            Sz = Mulliken spin populations, in the same order as X
            LFwd = Length of the forward segment (i.e. before it goes back to the TS)
            LBak = Length of the backward segment
            MFwd = Status message of the forward IRC calculation
            MBak = Status message of the backward IRC calculation
            M = Molecule object containing initial frame (may be useful)
            Status messages are: 
            'IRC-Ok' = Best result, IRC converged to the minimum
            'Opt-Ok' = Good result, IRC failed and we picked up using a geometry optimization
            qcerr = Bad result, returns error message from failed Q-Chem calculation

        """
        if direction not in [1, -1]: 
            raise RuntimeError('direction must be +1 or -1')
        self.jobtype = 'rpath'
        # The maximum number of IRC cycles is set to 50.  In reality, each
        # IRC cycle is actually four energy calculations so it's very expensive!
        # In any case, when IRC fails we "catch" it with a geometry optimization
        # and continue on to the minimum.
        self.remextra = OrderedDict([('rpath_direction', direction),
                                     ('rpath_tol_displacement', tolerance),
                                     ('rpath_max_cycles', 50),
                                     ('geom_opt_max_cycles', 300)])
        if self.haveH:
            self.remextra['geom_opt_hessian'] = 'read'

        xyz0 = deepcopy(self.M.xyzs)
        # Save the Q-Chem hessian directory if we need to rerun the reaction path.
        if os.path.exists(self.qcdir):
            _exec("rm -rf %s %s1" % (self.qcdsav, self.qcdsav), print_command=False)
            _exec("cp -r %s %s1" % (self.qcdir, self.qcdsav), print_command=False)

        self.calculate()
        # By this point what might we have generated:
        # 1) IRC calculation success in both directions! :)
        # 2) IRC calculation ran out of cycles in either direction
        #    - Solution: Run geometry optimization in the direction where it didn't finish
        # 3) IRC calculation SCF failure, picked up with Geometry Optimization
        #    - Solution: Start IRC calculation in backward direction if forward direction terminated.
        # 4) Irrecoverable failure in either direction
        #    - No solution
        # What do we return?
        # Previously we just concatenated Q-Chem output files.  This is a bit clunky.
        # Let's simply reconstruct our Molecule object instead.
        # Output data.
        M1 = self.load_qcout()
        IRCOut = OrderedDict([('M', M1[0]), ('X', []), ('E', []), ('Q', []), ('Sz', []), ('LFwd', 0), ('LBak', 0), ('MFwd', 'No Result'), ('MBak', 'No Result')])
        # Get the irrecoverable failures out of the way.
        if M1.Irc[0]['stat'] in [-1, 2]:
            IRCOut['MFwd'] = M1.qcerr
            return IRCOut
        # Read information from the first half of the path.
        if M1.Irc[0]['stat'] in [0, 1]:
            for i in ['X', 'E', 'Q', 'Sz']: IRCOut[i] += M1.Irc[0][i]
            IRCOut['MFwd'] = 'IRC-Ok'
            IRCOut['LFwd'] += len(M1.Irc[0]['X'])
        # If we need to continue the geometry optimization, do so
        # and then append the output data to the IRC data structure.
        def append_opt(M_, RCDir, flip=False):
            self.M.xyzs = [M_.Irc[RCDir]['X'][-1]]
            self.opt()
            M2 = self.load_qcout()
            IRCOut['X'] += M2.xyzs[1:]
            IRCOut['E'] += M2.qm_energies[1:]
            IRCOut['Q'] += M2.qm_mulliken_charges[1:]
            IRCOut['Sz'] += M2.qm_mulliken_spins[1:]
            if flip:
                IRCOut['MBak' if RCDir==0 else 'MFwd'] = 'Opt-Ok'
                IRCOut['LBak' if RCDir==0 else 'LFwd'] += len(M2)-1
            else:
                IRCOut['MFwd' if RCDir==0 else 'MBak'] = 'Opt-Ok'
                IRCOut['LFwd' if RCDir==0 else 'LBak'] += len(M2)-1
        if M1.Irc[0]['stat'] == 1: append_opt(M1, 0)

        # Reverse the IRC data so that it ends in the transition state.
        for i in ['X', 'E', 'Q', 'Sz']: IRCOut[i] = IRCOut[i][::-1]
        # Now read the second IRC direction.
        if M1.Irc[1]['stat'] in [0, 1]:
            for i in ['X', 'E', 'Q', 'Sz']: IRCOut[i] += M1.Irc[1][i][1:]
            IRCOut['MBak'] = 'IRC-Ok'
            IRCOut['LBak'] += len(M1.Irc[1]['X'])-1
        # If we need to continue the geometry optimization, do so
        # and then append the output data to the IRC data structure.
        if M1.Irc[1]['stat'] == 1: append_opt(M1, 1)
        # If the forward direction caused the calculation to quit, then we must repeat the calculation
        # in the backward direction and treat the first half of the reversed IRC as the second half of
        # the forward IRC.
        if M1.Irc[1]['stat'] in [-1, 2]:
            # Recover the Q-Chem calculation from what we had at the start.
            self.M.xyzs = deepcopy(xyz0)
            shutil.rmtree(self.qcdsav)
            shutil.rmtree(self.qcdir)
            if os.path.exists("%s1" % self.qcdsav):
                _exec("cp -r %s1 %s" % (self.qcdsav, self.qcdir), print_command=False)
            self.jobtype = 'rpath'
            self.remextra = OrderedDict([('rpath_direction', -1*direction),
                                         ('rpath_tol_displacement', tolerance),
                                         ('rpath_max_cycles', 50),
                                         ('geom_opt_max_cycles', 300)])
            if self.haveH:
                self.remextra['geom_opt_hessian'] = 'read'
            self.calculate()
            M3 = self.load_qcout()
            # Get the irrecoverable failures out of the way.
            if M3.Irc[0]['stat'] == 2:
                IRCOut['MBak'] = M3.qcerr
            if M3.Irc[0]['stat'] in [0, 1]:
                for i in ['X', 'E', 'Q', 'Sz']: IRCOut[i] += M3.Irc[0][i][1:]
                IRCOut['LBak'] += len(M3.Irc[0]['X'])-1
                IRCOut['MBak'] = 'IRC-Ok'
            if M3.Irc[0]['stat'] == 1: 
                append_opt(M3, 0, flip=True)
        return IRCOut

def QChemTS(xyz, charge, mult, method, basis, initial_stable=True, final_stable=True, finalize=False, qcin='qcts.in', vout=None):
    """
    Perform a series of calculations to obtain the transition state,
    starting from an initial guess.  The sequence of calculations are:
    
    1) Stability analysis (if requested)
    2) Frequency calculation
    3) Transition state optimization
    4) Stability analysis (if requested), if not return to (2).
    5) Final frequency calculation

    Parameters
    ----------
    xyz : str
        Input xyz file for running IRC calculation
    charge : int
        Net charge
    mult : int
        Spin multiplicity
    method : str
        Electronic structure method (e.g. b3lyp)
    basis : str
        Gaussian basis set (e.g. 6-31g*)
    initial_stable : bool
        Perform a stability analysis prior to any calculations.
    final_stable : bool
        Perform a stability analysis after finishing the TS calculation.
    finalize : bool
        Do a final Hessian calculation at the conclusion of the calculation.
    qcin : str
        Base name for the Q-Chem calculations.
    
    Returns
    -------
    QChem object containing transition state result.
    """
    QCTS = QChem(xyz, charge=charge, mult=mult, method=method, basis=basis, qcin=qcin)
    if initial_stable:
        print("Initial HF/KS stability analysis.")
        QCTS.make_stable()
        
    #----
    # Perform the following until a KS-stable transition state is found:
    # 1) Run frequency calculation
    # 2) Run transition state calculation
    # 3) Run stability analysis calculation on TS
    #----
    while True:
        print("Frequency calculation.")
        QCTS.freq()
        print("Transition state optimization.")
        QCTS.ts()
        # If we're not worrying about stability, then quit right now.
        if not final_stable: 
            if finalize:
                # Run frequency calculation to start off IRC!
                print("Final frequency calculation.")
                QCTS.freq()
                if vout != None: QCTS.write_vdata(vout)
            break
        print("Ensuring HF/KS stability of optimized structure.")
        QCTS.make_stable()
        if QCTS.nstab == 1:
            if finalize:
                # Run frequency calculation to start off IRC!
                print("HF/KS stable; final frequency calculation.")
                QCTS.freq()
                if vout != None: QCTS.write_vdata(vout)
            else:
                print("HF/KS stable")
            break
        else:
            print("HF/KS unstable, redoing transition state.")
    return QCTS

def ProcessIRC(IRCData, xyz0=None):
    """
    Save IRC data to an output .xyz file.

    Parameters
    ----------
    IRCData : dict
        Dictionary containing IRC information
    xyz0 : str, optional
        Initial pathway .xyz file name (for determining direction only)

    Returns
    -------
    M : Molecule
        Molecule object containing IRC coordinates and energies in comments
    E : np.ndarray
        IRC energies in kcal/mol referenced to initial frame
    """
    def GetRMSD(mol, frame, xtrial):
        """ Get the RMSD between mol[frame] and xtrial. """
        tmp = mol[frame]
        tmp.xyzs.append(xtrial)
        tmp.align()
        RMSD = np.sqrt(np.mean((tmp.xyzs[1] - tmp.xyzs[0]) ** 2))
        return RMSD
    # First get RMSD of IRC endpoints to the string endpoints.
    # Reverse the string if the sum of the RMSDs is smaller for the reversed string.
    if xyz0 != None:
        S = Molecule(xyz0, ftype='xyz')
        RMSD1 = GetRMSD(S, 0, IRCData['X'][0]) + GetRMSD(S, -1, IRCData['X'][-1])
        RMSD2 = GetRMSD(S, 0, IRCData['X'][-1]) + GetRMSD(S, -1, IRCData['X'][0])
        print("IRC RMSD to initial path endpoints (fwd, bkwd) = %6.3f %6.3f" % (RMSD1, RMSD2))
        fwd = (RMSD1 < RMSD2)
        M = S[0]
    else:
        fwd = True
        M = Molecule()
        M.elem = IRCData['M'].elem
    # Get coordinates and Mulliken populations from IRCData.
    M.xyzs = IRCData['X'] if fwd else IRCData['X'][::-1]
    if 'Q' in IRCData: M.qm_mulliken_charges = IRCData['Q'] if fwd else IRCData['Q'][::-1]
    if 'Sz' in IRCData: M.qm_mulliken_spins = IRCData['Sz'] if fwd else IRCData['Sz'][::-1]
    # Get IRC energies in kcal/mol referenced to the initial frame.
    E = np.array(IRCData['E'] if fwd else IRCData['E'][::-1])
    E_kc = E.copy()
    E_kc -= E[0]
    E_kc *= 627.51
    # The frame number of the transition state.
    iTS = (IRCData['LFwd']-1 if fwd else IRCData['LBak'])
    # Write IRC energies to comments.
    M.comms = ["Energy = % 16.10f ; %+.4f kcal/mol" % (i, j) for i, j in zip(E, E_kc)]
    M.comms[iTS] += " (Transition State)"
    # Eliminate geometry optimization frames that go up in energy.
    selct = np.concatenate((monotonic_decreasing(E, iTS, 0)[::-1], monotonic_decreasing(E, iTS, len(M)-1)[1:]))
    M = M[selct]
    E = E[selct]
    for i in range(len(M)):
        M.comms[i] = "Frame %3i IRC: " % i + M.comms[i]
    # Write structures and populations.
    M.align_center()
    return M, E

def QChemIRC(xyz, charge, mult, method, basis, qcdir, qcin='qcirc.in', xyz0=None):
    """
    Perform an intrinsic reaction coordinate calculation.  In case
    calculation doesn't work, ratchet up the tolerance until it does
    (or give up).

    Parameters
    ----------
    xyz : str
        Input xyz file for running IRC calculation
    charge : int
        Net charge
    mult : int
        Spin multiplicity
    method : str
        Electronic structure method (e.g. b3lyp)
    basis : str
        Gaussian basis set (e.g. 6-31g*)
    qcdir : str
        Initial qcdir containing Q-Chem temporary files (with TS Hessian).
    qcin : str
        Base name of the IRC calculation.
    xyz0 : str, optional
        Initial pathway .xyz file name, for determining direction only

    Returns
    -------
    M : Molecule
        Molecule object containing IRC coordinates and energies in comments
    E : np.ndarray
        IRC energies in kcal/mol referenced to initial frame
    """

    def IRCOne(tol):
        """
        Perform a single IRC calculation with a particular tolerance.
        """
        # Set up Q-Chem IRC calculation and copy the temp directory from the frequency calculation.
        QCIRC = QChem(xyz, charge=charge, mult=mult, method=method, basis=basis, qcin=qcin)
        _exec("rm -rf %s" % QCIRC.qcdir, print_command=False)
        _exec("cp -r %s %s" % (qcdir, QCIRC.qcdir), print_command=False)
        QCIRC.haveH = 1
        # Run IRC calculation.
        IRCOut = QCIRC.rpath(direction=1, tolerance=tol)
        msg = []
        msg.append("IRC calculation with displacement tolerance %i." % tol)
        # If IRC fails with something like "Bad initial gradient", then quit immediately.
        if not all(['Ok' in i for i in [IRCOut['MFwd'], IRCOut['MBak']]]):
            print("\x1b[1;91mIRC Failure :(\x1b[0m")
            print("Forward direction: %s" % IRCOut['MFwd'])
            print("Backward direction: %s" % IRCOut['MBak'])
            tarexit()
        else:
            msg.append("Forward direction: %s" % IRCOut['MFwd'])
            msg.append("Backward direction: %s" % IRCOut['MBak'])
            return IRCOut, msg

    def min_irc_steps(tol):
        """
        Get the minimum number of IRC steps considered to be a valid calculation.
        """
        if tol >= 1000: return 5
        elif tol >= 100: return 7
        elif tol >= 10: return 9
        else: return 11

    tol = 1000
    print("Intrinsic Reaction Coordinate (IRC) calculation.")
    while True:
        # The IRC calculation has a funny way of terminating before
        # actually reaching the bottom of the hill, so we tighten the
        # tolerance successively until it does.  If the tolerance
        # drops below zero, give up.
        IRCOut, msg = IRCOne(tol)
        if min(IRCOut['LFwd'], IRCOut['LBak']) < min_irc_steps(tol):
            tol //= 2
            print("IRC segments are too short - tightening the tolerance (%i)" % tol)
            if tol < 10: 
                for line in msg:
                    print(line)
                print("\x1b[1;91mIRC Failure: Segments are too short\x1b[0m")
                tarexit()
        else:
            for line in msg:
                print(line)
            break
    return ProcessIRC(IRCOut, xyz0)

def SpaceIRC(M, E, RMSD=True):
    """
    Create a Molecule object with frames spaced by 0.05 Angstrom.
    Useful for creating smooth animations and more intuitive-looking
    energy plots.

    Parameters
    ----------
    M : Molecule object 
        IRC coordinates
    E : np.ndarray 
        IRC energies
    RMSD : bool
        Use RMSD for calculating arc length, 
        otherwise use maximum displacement.
    
    Returns
    -------
    M_EV : Molecule
        IRC coordinates equally spaced using 0.05 Angstrom spacing.
        Energies in comments are linearly interpolated.
        EV stands for "equal velocity".
    """
    # Calculate arc length of coordinates in M
    M_EV = Molecule()
    M_EV.elem = M.elem
    ArcMol = arc(M, RMSD=RMSD)
    ArcMolCumul = np.insert(np.cumsum(ArcMol), 0, 0.0)
    # Create linearly interpolated coordinates and energies
    dx = 0.05 
    npts = int(max(ArcMolCumul)/dx)
    if npts == 0: 
        print("\x1b[91mFailure: Path length is < %f Angstrom\x1b[0m" % dx)
        tarexit()
    ArcMolEqual = np.linspace(0, max(ArcMolCumul), npts)
    xyzold = np.array(M.xyzs)
    xyznew = np.zeros((npts, xyzold.shape[1], xyzold.shape[2]), dtype=float)
    for a in range(M.na):
        for i in range(3):
            xyznew[:,a,i] = np.interp(ArcMolEqual, ArcMolCumul, xyzold[:, a, i])
    # print E[0], E[-1], max(E)
    Enew = np.interp(ArcMolEqual, ArcMolCumul, E)
    E_kc = 627.51*(Enew - Enew[0])
    # print Enew[0], Enew[-1], max(Enew)
    M_EV.comms = ["Frame %3i IRC: Energy = % 16.10f ; %+.4f kcal/mol" % (ii, i, j) for ii, (i, j) in enumerate(zip(Enew, E_kc))]
    # M_EV.comms = ["Intrinsic Reaction Coordinate: Energy = % .4f kcal/mol" % i for i in Enew]
    M_EV.comms[np.argmax(Enew)] += " (Transition State)"
    M_EV.xyzs = list(xyznew)
    return M_EV

def SpaceIRC2(M, E, RMSD=True, pause=0, sweep=0, num=0):
    """
    Create a Molecule object with frames spaced by 0.05 Angstrom.
    Useful for creating smooth animations and more intuitive-looking
    energy plots.

    Parameters
    ----------
    M : Molecule object 
        IRC coordinates
    E : np.ndarray 
        IRC energies
    RMSD : bool
        Use RMSD for calculating arc length, 
        otherwise use maximum displacement.
    
    Returns
    -------
    M_EV : Molecule
        IRC coordinates equally spaced using 0.05 Angstrom spacing.
        Energies in comments are linearly interpolated.
        EV stands for "equal velocity".
    """
    # Calculate arc length of coordinates in M
    imax = np.argmax(E)

    def space_piece(M_, E_, Emin):
        M_EV = Molecule()
        M_EV.elem = M.elem
        ArcMol = arc(M_, RMSD=RMSD)
        ArcMolCumul = np.insert(np.cumsum(ArcMol), 0, 0.0)
        # Create linearly interpolated coordinates and energies
        dx = 0.05 
        npts = int(max(ArcMolCumul)/dx)
        if npts == 0: 
            print("\x1b[91mFailure: Path length is < %f Angstrom\x1b[0m" % dx)
            tarexit()
        ArcMolEqual = np.linspace(0, max(ArcMolCumul), npts)
        xyzold = np.array(M_.xyzs)
        xyznew = np.zeros((npts, xyzold.shape[1], xyzold.shape[2]), dtype=float)
        for a in range(M.na):
            for i in range(3):
                xyznew[:,a,i] = np.interp(ArcMolEqual, ArcMolCumul, xyzold[:, a, i])
        Enew = np.interp(ArcMolEqual, ArcMolCumul, E_)
        E_kc = 627.51*(Enew - Emin)
        M_EV.comms = ["Energy = % 16.10f ; %+.4f kcal/mol" % (i, j) for i, j in zip(Enew, E_kc)]
        for i in range(1, len(M_EV)-1):
            M_EV.comms[i] += " interpolated"
        M_EV.comms[np.argmax(Enew)] += " (Transition State)"
        M_EV.xyzs = list(xyznew)
        return M_EV

    M1 = space_piece(M[:imax+1], E[:imax+1], E[0])[:-1]
    M2 = space_piece(M[imax:], E[imax:], E[0])
    for i in range(len(M1)):
        M1.comms[i] = "Frame %3i IRC: " % i + M1.comms[i]
    for i in range(len(M2)):
        M2.comms[i] = "Frame %3i IRC: " % (i+len(M1)) + M2.comms[i]
    
    for i in range(pause):
        M1 += M2[0]

    if len(M2) < sweep or len(M1) < sweep:
        print("Warning: Sweep is longer than one piece of the IRC")
    vib = M2[:sweep/2+1] + M2[:sweep/2+1][::-1] + M1[-sweep/2:][::-1] + M1[-sweep/2:]
    for i in range(num):
        M1 += vib

    return M1 + M2

    # M_EV.comms = ["Intrinsic Reaction Coordinate: Energy = % .4f kcal/mol" % i for i in Enew]
    # M_EV.comms[np.argmax(Enew)] += " (Transition State)"
    # M_EV.xyzs = list(xyznew)
    # return M_EV

